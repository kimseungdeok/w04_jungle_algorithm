def fib(n):

    if n == 0:
        return 0

    # a와 b는 각각 수열의 처음 두 수로 시작한다.
    a = 0
    b = 1

    # 1부터 n까지 루프를 수행한다
    for i in range(1, n):

        # a와 b는 각각 수열의 다음 수로 이동한다.
        # 즉, b는 b + a 가 되고 a는 바로 이전의 b가 된다.
        # 임시 변수를 사용해 바꾼다.
        temp = a
        a = b
        b = temp + a

    return b
# 시간복잡도는 메모이제이션과 마찬가지로 O(N)
# 메모이제이션을 쓰더라도 재귀가 반복에 비해 오버헤드가 더 든다는 사실을 간과해서는 안된다.
# 재귀를 어떻게 사용하든 컴퓨터는 호출 스택에 모든 호출을 기록해야 하므로 메모리를 소비한다.
# 재귀가 매우 직관적이지 않은 이상 일반적으로 상향식을 택하는 편이 더 낫다.
# 재귀가 더 직관적이면 재귀를 사용하되 메모이제이션으로 빠르게 만들어야 한다.

print(fib(30))
